{"componentChunkName":"component---src-templates-blogs-post-js","path":"/arquitecture-lol-app/","result":{"data":{"site":{"siteMetadata":{"title":"Fabran99"}},"markdownRemark":{"id":"128c7a3c-c58b-5cb6-8905-70895705c878","excerpt":"This is the first of several blogs, where I will explain my process when developing the League of Legends assistant app, there is a previous…","rawMarkdownBody":"\r\n![app image ](img1.png)\r\nThis is the first of several blogs, where I will explain my process when developing the League of Legends assistant app, there is a [previous post](/portfolio-work-1) in my portfolio, where I briefly comment on how it works and what it does.\r\n\r\n# App needs\r\nAs I mentioned in the post about the app, the main objective is to generate **updated statistics for each character**, so that without having to be reading the game patches, **the player can make decisions** about which characters to choose or block, as well as what equipment to carry.\r\n\r\nBefore designing the architecture, the first thing we need is to know what resources we have and where we are going to get the information.\r\nIn this case, RiotGames [provides us with an API](https://developer.riotgames.com/apis), where you can obtain **information about players and their games**.\r\n\r\nThe api provides us with a couple of key endpoints that we must use to reach the final data, which is the final information of each champion used in a match.\r\n\r\n## Available Endpoints\r\n- **/lol/league/v4/entries/{queue}/{tier}/{division}**: Gives us a list of players in a league\r\n- **/lol/match/v4/matchlists/by-account/**: Gives us a list of a player's matches\r\n- **/lol/match/v4/matches/**: Gives us the detail of a specific match\r\n\r\nBased on these endpoints, the process to reach the match detail and obtain the data of each champion is as follows:\r\n1. We obtain a list of players from each league/division\r\n2. We obtain a list of matches by going through those players\r\n3. We go through those matches and get the detail of each one\r\n\r\n## API Limitations \r\nThe api limits us to a certain amount of requests per minute, however, **this limit applies per server**, that is, if we exceed the limit on the Korean server, we can continue making requests from the North American server. From this comes a strategy to optimize requests that I will detail later.\r\n\r\n## Plan and Architecture\r\n![Architecture](./model-architecture.jpg)\r\nThe plan is to use the [Celery](https://docs.celeryproject.org/en/stable/) library to keep processes running that go obtaining match data, and in turn updating both the list of players and the list of matches, discarding old ones and removing inactive players from the list that we are not going to obtain information from.\r\n\r\nFrom this a series of processes arise that will run on the server to carry out these tasks, I will number some of the most important:\r\n\r\n### 1 - Player Collection\r\n![Code block 1](./code1.png)\r\n\r\nThrough **Celery Beat**, every other day a tour is made of each available server, league and division, **storing all player information in PostgreSQL**. From each of them the server they belong to, their league, division, name and various IDS that are later required to make other requests with the api are stored.\r\n\r\n### 2 - Game Collection\r\n![Code block 2](./code2.png)\r\n\r\nUsing [Supervisor](http://supervisord.org/running.html), a process is kept running for each server, each of them going through the list of players associated with that server, getting a list of recent matches.\r\n\r\nFor each player, the last date on which this process checked it is obtained, so that the next time their matches are requested, it is only done with matches after that date. This way, duplicates are avoided.\r\n\r\nOnce the matches of the players in a certain region are obtained, they are stored in a Redis list, where the key is the region of the match.\r\n\r\n### 3 - Getting Match Details\r\n![Code block 3](./code3.png)\r\nAlso using supervisor, a handful of matches are extracted from the Redis queue of matches to be processed from each server (this way we avoid to some extent the API request limit).\r\n\r\nThese matches go to a Celery worker queue where their detail is requested, the information of each player who participated in it and everything relevant to it is stored in PostgreSQL.\r\n\r\nSome of the data obtained from each match are: Characters played and blocked, kills, deaths and assists of each character, items and runes of each character, number of minions killed by each player, line of each character, among others.\r\n\r\n### 4 - Obtaining Statistics\r\n![Code block 4](./code4.PNG)\r\nOnce a good number of matches have been obtained (I have managed with about 100,000), what is done is to use pandas to obtain statistics for each character. This process is executed through Celery Beat every 24 hours or when a patch change is detected in the game, to keep the statistics updated.\r\n\r\nIn 100,000 matches, with 10 players, there is a sampling of 1,000,000 total data if divided by character. In this way we can obtain the following data for each character:\r\n\r\n- Frequent lines in which it is played\r\n- Ratio of times it is chosen/blocked\r\n- Win/loss ratio\r\n- Items and runes with a higher success rate\r\n- Characters against which you win/lose more \r\n- In which minute of the match you win/lose more\r\n\r\nSome of these statistics are relevant to contrast them according to the line being played, that is, the equipment of a character can be very different if it is being played as Support or Middle. In this way we can obtain **several different builds for each character according to the assigned line.**\r\n\r\nThese statistics have a considerably complex structure, and are stored in MongoDB.\r\nThe analysis of the data is too extensive to comment on in detail in this post, but perhaps I will write about it later.\r\n\r\n# Final comments\r\n\r\nAt this point we have already obtained the statistics of each character in each line, so in the next post I will be writing about how I designed the frontend, what functionalities it has and what technologies I used.\r\n\r\n[Next post - App Frontend](/frontend-lol-app/)\r\n","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.83783783783784%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACu0lEQVQozx2SWW/bRhRGGcSWRInrDGfI4b6vEimRsvbIjuPYkeQ6XhLHjYUsblrAL0WAFtmQlwJ9L/qPy/Tl4lycD7gP96MYxaeR3QRmU9QbgtqRLFELRDUAegj0ABg1BNCI2pJF/8gYnOJxiltPoIXUg13hYQs8bItNQd0VCKfYbtLXvTjMhnFvEmdTPy6dqGiB2uI2UFu8vMPiNtSw4VM3I+3Y57sNoZ8fTA9vomSIiSQCH/N7qJMnD7Y95+rxxd2zk9tH1enz9cXq9ne3u1o+vhwvltSfH1//evdqbg+7veXq/EOshxoS8+E2yF+pUqkykzhYnG/ur/e3h9bei4ubL3//+8/Xv367/46tlNo8+eVk82mozKvx8fr2DycoFKwZ/tNw9RGhlGUNIxhUR9dZNN8jQTF4tD6720zPtmd3WT6mXr7/fPH226g6TcNyunnnV4cyMXV7tlf+nGiJwGiqly9O36T9o1hP+0kxHS0FlEGUOkGfen79bvbms1089dPB/vFpkExsM/XcfDo5kbFLJCdMqtX6RZTvp+liWc1ers9ds5+6pWbGVDa/7K3urfKn0uuOkj4AugCjUejP8xhIfuwVVfSkiI8gsLHgJbPR8NkRgn5oD3w/o+rXMVLQZLVOh9AMbrDyLoNbHG7zCi3oDDRonrRYpcmTBoNaUKWh2uBqpXWASsmwRFyq0Yu8+b7F64xsc7LTlkwa6k2BsMj8nw2eeG1kiloE9UhUfYF4u5xMpdmW4NLhD0hnzOBA8cZOOoZm3sahksxJdgCNruwUyOyJWip7fWT/AGT1GrxCZVffkTUXWZcTPVq0g2Cuel0rruoL0BmgcFLXUNIjQAJedqER1yuHXYH4OyyierMPgd4FnMYwpMnr3Wwhm75ixzw2RLuA/oiXLajYQLZZyRANV9ScGjhk7nTgfyR2dmjBEiDLAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"app image \"\n        title=\"app image \"\n        src=\"/static/af91051f1ac3254778715ff6b260308b/fcda8/img1.png\"\n        srcset=\"/static/af91051f1ac3254778715ff6b260308b/12f09/img1.png 148w,\n/static/af91051f1ac3254778715ff6b260308b/e4a3f/img1.png 295w,\n/static/af91051f1ac3254778715ff6b260308b/fcda8/img1.png 590w,\n/static/af91051f1ac3254778715ff6b260308b/efc66/img1.png 885w,\n/static/af91051f1ac3254778715ff6b260308b/2bef9/img1.png 1024w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>\nThis is the first of several blogs, where I will explain my process when developing the League of Legends assistant app, there is a <a href=\"/portfolio-work-1\">previous post</a> in my portfolio, where I briefly comment on how it works and what it does.</p>\n<h1>App needs</h1>\n<p>As I mentioned in the post about the app, the main objective is to generate <strong>updated statistics for each character</strong>, so that without having to be reading the game patches, <strong>the player can make decisions</strong> about which characters to choose or block, as well as what equipment to carry.</p>\n<p>Before designing the architecture, the first thing we need is to know what resources we have and where we are going to get the information.\nIn this case, RiotGames <a href=\"https://developer.riotgames.com/apis\">provides us with an API</a>, where you can obtain <strong>information about players and their games</strong>.</p>\n<p>The api provides us with a couple of key endpoints that we must use to reach the final data, which is the final information of each champion used in a match.</p>\n<h2>Available Endpoints</h2>\n<ul>\n<li><strong>/lol/league/v4/entries/{queue}/{tier}/{division}</strong>: Gives us a list of players in a league</li>\n<li><strong>/lol/match/v4/matchlists/by-account/</strong>: Gives us a list of a player’s matches</li>\n<li><strong>/lol/match/v4/matches/</strong>: Gives us the detail of a specific match</li>\n</ul>\n<p>Based on these endpoints, the process to reach the match detail and obtain the data of each champion is as follows:</p>\n<ol>\n<li>We obtain a list of players from each league/division</li>\n<li>We obtain a list of matches by going through those players</li>\n<li>We go through those matches and get the detail of each one</li>\n</ol>\n<h2>API Limitations</h2>\n<p>The api limits us to a certain amount of requests per minute, however, <strong>this limit applies per server</strong>, that is, if we exceed the limit on the Korean server, we can continue making requests from the North American server. From this comes a strategy to optimize requests that I will detail later.</p>\n<h2>Plan and Architecture</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.08108108108109%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAECAwQF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB6acCo0B//8QAGhAAAgMBAQAAAAAAAAAAAAAAAAECEjEDI//aAAgBAQABBQKU6q9T1NOcUh7/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAMBAQAAAAAAAAAAAAAAAAABERAy/9oACAEBAAY/AlSnRHv/xAAdEAEAAgICAwAAAAAAAAAAAAABESEAMRBBYXGR/9oACAEBAAE/ISoRfmSEmnR3jNkr7x2sPOSEGmuL/9oADAMBAAIAAwAAABCwz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQADAAMBAQAAAAAAAAAAAAEAESExcYFRYf/aAAgBAQABPxAB05bnr5Nl2aGuoV0E4L48ISoK+NQI4ppuurml+T//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Architecture\"\n        title=\"Architecture\"\n        src=\"/static/c163e391b3e3ca06eca4fee44b33be79/1c72d/model-architecture.jpg\"\n        srcset=\"/static/c163e391b3e3ca06eca4fee44b33be79/a80bd/model-architecture.jpg 148w,\n/static/c163e391b3e3ca06eca4fee44b33be79/1c91a/model-architecture.jpg 295w,\n/static/c163e391b3e3ca06eca4fee44b33be79/1c72d/model-architecture.jpg 590w,\n/static/c163e391b3e3ca06eca4fee44b33be79/a8a14/model-architecture.jpg 885w,\n/static/c163e391b3e3ca06eca4fee44b33be79/fbd2c/model-architecture.jpg 1180w,\n/static/c163e391b3e3ca06eca4fee44b33be79/0f98f/model-architecture.jpg 1920w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>\nThe plan is to use the <a href=\"https://docs.celeryproject.org/en/stable/\">Celery</a> library to keep processes running that go obtaining match data, and in turn updating both the list of players and the list of matches, discarding old ones and removing inactive players from the list that we are not going to obtain information from.</p>\n<p>From this a series of processes arise that will run on the server to carry out these tasks, I will number some of the most important:</p>\n<h3>1 - Player Collection</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 466px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cc32495a2657077401bb5352624f868e/fc1a1/code1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.2972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA1UlEQVQY002PSW7DMBAE/Y9YC02KiyiR1G5ZToDk/3+qUDoEORRmwXSj5xbHhPY9zjW0nceECdt6QugzAWsNUlu66YkzhuQ0nWnwWhGsxjXywjaKoiy5desXcVn5+V443ivPY2ffZ9Z15DhWUoxI1SBNixQCIwVaPv6Mzr55CGSmPA2rSuREhtfnQhoDU/LMmSk4xtDyzrstz2eyeN5NgaVvr3RKKT7ud4qiuLgMRV0jnEUNAZl65BhR3uWEiTmLh6Fj29JVU/TsrwWdX66qijprz/qfX46vdyE/crODAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Code block 1\"\n        title=\"Code block 1\"\n        src=\"/static/cc32495a2657077401bb5352624f868e/fc1a1/code1.png\"\n        srcset=\"/static/cc32495a2657077401bb5352624f868e/12f09/code1.png 148w,\n/static/cc32495a2657077401bb5352624f868e/e4a3f/code1.png 295w,\n/static/cc32495a2657077401bb5352624f868e/fc1a1/code1.png 466w\"\n        sizes=\"(max-width: 466px) 100vw, 466px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Through <strong>Celery Beat</strong>, every other day a tour is made of each available server, league and division, <strong>storing all player information in PostgreSQL</strong>. From each of them the server they belong to, their league, division, name and various IDS that are later required to make other requests with the api are stored.</p>\n<h3>2 - Game Collection</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 530px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b70f1b1686e6830287511c387e79bfc0/b6a9b/code2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.32432432432432%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABmUlEQVQoz21S7ZKjIBDMa+xGvgQVRFHEjWZrL3V5/4fqHUg2l2zdjy5AZ3q6Gw6q9ahtgJ5GNCnAphndEmAy1gXGWTAuIFQNzjlYVaGqjmCMFZQ9fWMVnen/QUgJ1Y1wccF2OWP72nC5fuJ0XrH++YtpPWGcE5aPHa5rIWsN0znUSkJSr24tlDGQmgbSgIMoU49QVNj6gIaKfe/hrMMcSLG16BoD3xpoKaDz//gBQwRSKrgpoRnIJdUUQs4ZZNMT2YBlDYgx3IrcgG6Y0No8oCcSUrpu0Frj+P72z/LxnXC3XSwLUbIxjcV+vsITmaPmTGBDhCeFwTboO4spzsUmY/xBmEke+2L5TqhIfqcaap5IvrsHfQu/IuSa7EYIjtzzgMxQyHfBnxXmlZUGgXl22LcZp1NEihTFMiKlEcNgMU894jJgojWfh9HDkis73tS/EGZYY5EmIjonxMuOcU/wlK9z/q6SF5U/+994Icxrq1tEut1A7zA/JZZvUyio/A7Fa145y58oXgifUfKkN6brTELZPCn6Xfs/fAOx6B0ggye71gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Code block 2\"\n        title=\"Code block 2\"\n        src=\"/static/b70f1b1686e6830287511c387e79bfc0/b6a9b/code2.png\"\n        srcset=\"/static/b70f1b1686e6830287511c387e79bfc0/12f09/code2.png 148w,\n/static/b70f1b1686e6830287511c387e79bfc0/e4a3f/code2.png 295w,\n/static/b70f1b1686e6830287511c387e79bfc0/b6a9b/code2.png 530w\"\n        sizes=\"(max-width: 530px) 100vw, 530px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Using <a href=\"http://supervisord.org/running.html\">Supervisor</a>, a process is kept running for each server, each of them going through the list of players associated with that server, getting a list of recent matches.</p>\n<p>For each player, the last date on which this process checked it is obtained, so that the next time their matches are requested, it is only done with matches after that date. This way, duplicates are avoided.</p>\n<p>Once the matches of the players in a certain region are obtained, they are stored in a Redis list, where the key is the region of the match.</p>\n<h3>3 - Getting Match Details</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d003dcab40f768dba9f07f66bcbb05fb/e9beb/code3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABa0lEQVQoz22SWZLDIAxEc4/Y7ItZjLfJZO5/sR6BQ1yVykeXKAFPLcFN2gidC9Lvhvg4YLcVbt9gnIPSBlIZMMYwjuOl4Yw9X2PXjXNOFx2OuSBvB5SfIJRsUtZAewsuObhgLQp1inH2FdqAjI3gTCClgMffgsdzwX5krHtELh4brX1wDaishHbyDRxfoA59Ac+KLmqsR8T+LJgJZryCpZxLBjboBpJGNGnaq3BO99jIPh0ympXCNM9wOWNaCnwOiNkjRYsQLGS9LPjVJnU1vGY6DFUDrYcLyLmAnyLKvmBZMpJ3CDTDSZNDTU5pplrSGVoLQQ4pH62Gofw0WUwhwFh3AjtUSYm/nwNbKVCUE5SrYuRCkTtJUgSt5yWdrTBRH7UWowJSqsuhIIfZJ6xlxpwiubVwzrRYHVTA2db1fb62zN6vRFCqvu8Zy5oaTGtyYRRJtzY//9w33Xq1/vT3+9BUK/bK3dm3j/ypf4xxF3O/PtOvAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Code block 3\"\n        title=\"Code block 3\"\n        src=\"/static/d003dcab40f768dba9f07f66bcbb05fb/fcda8/code3.png\"\n        srcset=\"/static/d003dcab40f768dba9f07f66bcbb05fb/12f09/code3.png 148w,\n/static/d003dcab40f768dba9f07f66bcbb05fb/e4a3f/code3.png 295w,\n/static/d003dcab40f768dba9f07f66bcbb05fb/fcda8/code3.png 590w,\n/static/d003dcab40f768dba9f07f66bcbb05fb/e9beb/code3.png 730w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\nAlso using supervisor, a handful of matches are extracted from the Redis queue of matches to be processed from each server (this way we avoid to some extent the API request limit).</p>\n<p>These matches go to a Celery worker queue where their detail is requested, the information of each player who participated in it and everything relevant to it is stored in PostgreSQL.</p>\n<p>Some of the data obtained from each match are: Characters played and blocked, kills, deaths and assists of each character, items and runes of each character, number of minions killed by each player, line of each character, among others.</p>\n<h3>4 - Obtaining Statistics</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 487px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d65cfcaf751f7d855a7fe460ba9a03da/7b439/code4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCUlEQVQY012RaXaEIBCEPce4gSwCgozOFjPJ/Y9VKUziy+THZ2O97rJoq9s1Ic4z/PJgzTjnjHW9IMaIwTjMb5+I3mENI9aJ784gjQbZj9BKoW1bdF13UKXLHc+PG7bnA7f7gu39im274v5YsKxnuDhDDRJWK2hWo4a9Fm2QEn3fv1AJIZnAIlgOKA7oYcdZTRMOS8HGDg2TtP/4m+xIKOiayxVoMPKrgQkcmal5GiZrMLDndKrRNA3q+pWi/5qXWpWYKjjIyUNGj5770kyckscUHcI07uecAzz1SG2iNnGnaQ7cOXcth8O0Ko/eaIjRErOj3feg5w9wpBgVbLnFWPjRQ+nzEEIchl+D9qw5nJMWhwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Code block 4\"\n        title=\"Code block 4\"\n        src=\"/static/d65cfcaf751f7d855a7fe460ba9a03da/7b439/code4.png\"\n        srcset=\"/static/d65cfcaf751f7d855a7fe460ba9a03da/12f09/code4.png 148w,\n/static/d65cfcaf751f7d855a7fe460ba9a03da/e4a3f/code4.png 295w,\n/static/d65cfcaf751f7d855a7fe460ba9a03da/7b439/code4.png 487w\"\n        sizes=\"(max-width: 487px) 100vw, 487px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\nOnce a good number of matches have been obtained (I have managed with about 100,000), what is done is to use pandas to obtain statistics for each character. This process is executed through Celery Beat every 24 hours or when a patch change is detected in the game, to keep the statistics updated.</p>\n<p>In 100,000 matches, with 10 players, there is a sampling of 1,000,000 total data if divided by character. In this way we can obtain the following data for each character:</p>\n<ul>\n<li>Frequent lines in which it is played</li>\n<li>Ratio of times it is chosen/blocked</li>\n<li>Win/loss ratio</li>\n<li>Items and runes with a higher success rate</li>\n<li>Characters against which you win/lose more </li>\n<li>In which minute of the match you win/lose more</li>\n</ul>\n<p>Some of these statistics are relevant to contrast them according to the line being played, that is, the equipment of a character can be very different if it is being played as Support or Middle. In this way we can obtain <strong>several different builds for each character according to the assigned line.</strong></p>\n<p>These statistics have a considerably complex structure, and are stored in MongoDB.\nThe analysis of the data is too extensive to comment on in detail in this post, but perhaps I will write about it later.</p>\n<h1>Final comments</h1>\n<p>At this point we have already obtained the statistics of each character in each line, so in the next post I will be writing about how I designed the frontend, what functionalities it has and what technologies I used.</p>\n<p><a href=\"/frontend-lol-app/\">Next post - App Frontend</a></p>","frontmatter":{"title":"League of Legends Assistant Part 1 - Architecture","date":"October 16, 2021","description":"Part 1 of the League of Legends assistant app, in this first part I will talk about the architecture design to obtain statistics.","time":10}}},"pageContext":{"slug":"/arquitecture-lol-app/","previous":null,"next":{"fields":{"slug":"/frontend-lol-app/"},"frontmatter":{"title":"League of Legends Assistant Part 2 - Frontend","categories":["frontend"]}}}},"staticQueryHashes":["3649515864","63159454"]}